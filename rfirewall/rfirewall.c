#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <bpf/bpf.h>
#include <bpf/libbpf.h>
#include <sys/resource.h>
#include <arpa/inet.h>
#include <time.h>

#include <conn/tcpconnect.h>
#include <bpf/bpf-skeleton.h> // generated by build

static int
incr_rlimit_memlock()
{
	struct rlimit lim = {
		.rlim_cur = RLIM_INFINITY,
		.rlim_max = RLIM_INFINITY,
	};

	return setrlimit(RLIMIT_MEMLOCK, &lim);
}

static int 
libbpf_print_fn(enum libbpf_print_level lvl, const char *fmt, va_list args) 
{
	if (lvl == LIBBPF_DEBUG) {
		return 0;
	}

	return vfprintf(stderr, fmt, args);
}

volatile sig_atomic_t exiting = 0;

static void
termination_handler(int sig) 
{
	(void)sig;
	exiting = 1;
}

static void
handle_event(void *ctx, int cpu, void *data, __u32 data_sz)
{
	const struct event *e = data;
	char src[INET6_ADDRSTRLEN];
	char dst[INET6_ADDRSTRLEN];
	union {
		struct in_addr x4;
		struct in6_addr x6;
	} s, d;
	static __u64 start_ts;

	if (e->af == AF_INET) {
		s.x4.s_addr = e->saddr_v4;
		d.x4.s_addr = e->daddr_v4;
	} else if (e->af == AF_INET6) {
		memcpy(&s.x6.s6_addr, e->saddr_v6, sizeof(s.x6.s6_addr)); 		
		memcpy(&d.x6.s6_addr, e->daddr_v6, sizeof(d.x6.s6_addr)); 		
	} else {
		fprintf(stderr, "Broken event: e->af=%d", e->af);
		return;
	}

	if (start_ts == 0) {
		start_ts = e->ts_us;
	}
	printf("%-9.3f %-6d %-6d %-12.12s %-2d %-16s %-16s %-4d\n",
			(e->ts_us - start_ts) / 1000000.0,
			e->uid,
			e->pid,
			e->task,
			e->af == AF_INET ? 4 : 6,
			inet_ntop(e->af, &s, src, sizeof(src)),
			inet_ntop(e->af, &d, dst, sizeof(dst)),
			ntohs(e->dport));

}

static void
handle_lost_event(void *ctx, int cpu, __u64 lost_count)
{
	fprintf(stderr, "Lost '%llu' events on CPU #%d\n", lost_count, cpu);	
}

static void 
print_events_header() 
{
	printf("%-9s %-6s %-6s %-12s %-2s %-16s %-16s %-4s\n", 
			"TIME(s)", "UID", "PID", "COMM", "IP", "SADDR", "DADDR", "DPORT");
}

static void
print_events(int perf_map_fd) 
{
	struct perf_buffer *pbuf;	
	int err;

	pbuf = perf_buffer__new(perf_map_fd, 128, handle_event, handle_lost_event, NULL, NULL);
	if (pbuf == NULL) {
		fprintf(stderr, "Error with perf_buffer__new() '%d', '%s'",
			errno, strerror(errno));
		err = -errno;
		goto cleanup;
	}

	print_events_header();

	while (!exiting) {
		err = perf_buffer__poll(pbuf, 100);
		if (err < 0 && err != -EINTR) {
			fprintf(stderr, "Error polling perf buffer '%d', '%s'", -err, strerror(-err));
			goto cleanup;
		}
		err = 0; /* reset err to return 0 if exiting */
	}
	
cleanup:
	perf_buffer__free(pbuf);
}

int 
main(void) 
{
	struct combined_bpf_lib *obj = NULL;
	struct sigaction sa;
	int err;

	// signal handling for Ctrl+C
	// https://www.gnu.org/software/libc/manual/html_node/Sigaction-Function-Example.html
	sa.sa_handler = termination_handler;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0; // auto restarts interrupted syscalls
	if (sigaction(SIGINT, &sa, NULL) == -1) {
		fprintf(stderr, "Error with sigaction()'%d', '%s'",
			errno, strerror(errno));
		return 1;
	}
	
	err = incr_rlimit_memlock();
	if (err == -1) {
		fprintf(stderr, "Error increasing RLIMIT_MEMLOCK '%d', '%s'",
			errno, strerror(errno));
		return 1;
	}

	libbpf_set_print(libbpf_print_fn); 

	obj = combined_bpf_lib__open_and_load();
	if (obj == NULL) {
		fprintf(stderr, "Error opening and loading 'combined_bpf_lib *obj' '%d', '%s'",
			errno, strerror(errno));
		goto cleanup;	
	}

	err = combined_bpf_lib__attach(obj);
	if (err) {
		fprintf(stderr, "Error attaching skeleton '%d', '%s'",
			errno, strerror(errno));
		goto cleanup;	
	}

	printf("... Press Ctrl+C to stop.\n");
	print_events(bpf_map__fd(obj->maps.events));
	printf("\nExiting...\n");
	
cleanup:
	combined_bpf_lib__destroy(obj);
	return -err;
}

